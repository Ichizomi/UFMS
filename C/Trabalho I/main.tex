\documentclass[12pt,a4paper]{article}
\usepackage[portuges]{babel}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{epsfig}
%\usepackage[brazil]{babel}   
\usepackage[utf8]{inputenc}
\usepackage{subfigure}
%\usepackage[latin1]{inputenc}
\usepackage{indentfirst}
\usepackage{pgfplots}   % pacote para uso do pgfplots


\usepackage{listings}
%configuração do pacote listings
\lstset{numbers=left,stepnumber=1,firstnumber=1,numberstyle=\tiny,extendedchars=true,breaklines=true,
frame=tb,basicstyle=\footnotesize,stringstyle=\ttfamily,showstringspaces=false
,morecomment=[l]{//},morecomment=[s]{/*}{*/},}
%fim da configuração


%\input{Macro01.tex}
\setlength{\oddsidemargin }{0mm}  % margem esquerda para paginas impares
\setlength{\evensidemargin}{0mm}  % margem esquerda para paginas espelho
\setlength{\topmargin}{0mm}       % distancia da margem superior ao cabecalho
\setlength{\footskip}{15mm}       % distancia do texto ao rodape
\setlength{\headheight}{10mm}     % tamanho do cabecalho
\setlength{\headsep}{0mm}         % distancia do cabecalho ao inicio do texto
\setlength{\textheight}{230mm}    % comprimento do texto na pagina
\setlength{\textwidth}{154mm}     % largura do texto na pagina
\setlength{\parskip}{2ex}         % distancia entre dois paragrafos
\setlength{\parindent}{10mm}

\newcommand{\qed}{\hfill\rule{2.5mm}{2.5mm}}
\pagenumbering{arabic}

\begin{document}
%\vspace*{8cm}
\begin{center}
{\Large \sc Universidade Federal de Mato Grosso do Sul} \\ 
{\large \sc Facom - Faculdade de Computa\c{c}\~{a}o } \\ 
\vspace*{0.2cm}
{\bf Disciplina:} {\sc Algoritmos e Programação II} \\
{\bf Professora:} {\sc Liana Duenha } \\
{\bf Alunos:} \\
{\bf Pietro Dal Moro} \\
{\bf Lucas Grijó} \\
{\sc 2014} \\
\vspace*{0.3cm}
{\Large \sc Relatório de Experimentação} \\
\vspace*{0.3cm}
{\Large \sc Trabalho Prático 1} \\
\vspace*{0.5cm}
{\Large Comparação de Métodos de Ordenação}
\end{center}

\vspace*{1cm}

\section{Introdução}


Este relatório tem o propósito de comparar a complexidade de tempo dos cinco métodos (algoritmos) básicos de ordenação, são eles: Bubble Sort, Selection Sort, Insertion Sort, Merge Sort e Quick Sort.  Cada um deles utiliza uma filosofia de ordenação diferente, portanto seu tempo de execução é distinto mesmo para uma entrada igual. Além disso devemos levar a idéia em conta o pior caso e o melhor caso de cada algoritmo, que criam situações onde o algoritmo X pode ser mais eficiente que o Y para uma entrada assim como o Y pode ser melhor do que o X em uma outra entrada.
\vspace*{0.2cm}

Tais peculiaridades tornam impossível a seleção de um “melhor” algoritmo. E é por essa ideia indefinida que realizamos experimentos com os cinco métodos, testando seu tempo de execução e também adicionando uma simples variável em cada algoritmo para contar a quantidade de comparações. Entendemos por comparação toda vez que o algoritmo verifica se um valor em algum espaço do vetor é maior, igual ou menor que outro valor em outra posição desse vetor. Ao final deste relatório esperamos ter uma aproximação da realidade, através de diversos casos de teste, por trás da complexidade desses algoritmos tão usados na programação nos dias atuais.

\vspace*{1.5cm}

\section{Algoritmos Utilizados}

\begin{itemize}
 \item {\large Bubble Sort}
 
 O {\bf bubble sort}, ou também chamado de 'ordenação por flutuação', é um dos mais simples algoritmos de ordenação.Por percorrer o vetor diversas vezes e a cada passagem fazer flutuar para o topo o maior elemento da sequência, seu movimento assemelha-se a forma como as bolhas em um tanque de água procuram seu próprio nível, sendo conhecido assim, literalmente como método 'por bolha'.
 \begin{itemize}
 \item {\bf Complexidade Pior Caso:} $O(n^2)$
 \item {\bf Complexidade Caso Médio:} $O(n^2)$
 \item {\bf Complexidade Melhor Caso:} $O(n)$
 \end{itemize}
 
\end{itemize} 

\begin{figure}[htb]
\begin{lstlisting}[language=c]
int bubble_sort(int n, int v[MAX]){

    int i, j, temp;
    int contador_comp = 0;
    for(i=n-1; i>0; i--){

        for(j=0;j<i;j++){
        contador_comp++;
            if(v[j] > v[j+1]){
            temp = v[j+1]; 
            v[j+1] = v[j];
            v[j] = temp;
            }	
        }
    }
return contador_comp;
}

\end{lstlisting} 

\caption{Função Bubble Sort com Contador\label{main}}
\end{figure}

\vspace*{6.5cm}

\begin{itemize}
\item {\large Selection Sort}

O {\bf selection sort}, do inglês 'ordenação por seleção', se baseia em passar sempre o menor valor do vetor para a primeira posição (ou o maior, dependendo da ordem requerida), depois o segundo menor valor para a segunda posição, realizando essa operação sucessivamente para os (n-1) elementos restantes, até os últimos dois elementos.
 \begin{itemize}
 \item {\bf Complexidade Pior Caso:} $O(n^2)$
 \item {\bf Complexidade Caso Médio:} $O(n^2)$
 \item {\bf Complexidade Melhor Caso:} $O(n^2)$
 \end{itemize}

\end{itemize}

\begin{figure}[htb]
\begin{lstlisting}[language=c]
int selection_sort(int n, int v[MAX]){

    int i, j, min, temp;
    int contador_comp = 0;
    for(i=0;i<n-1; i++){
        min = i;
        for(j = i+1;j<n; j++){
            contador_comp++;
                if(v[j] < v[min]){	
                    min = j;
                }
            }
        temp = v[min];
        v[min] = v[i];
        v[i] = temp;	
        }
    return contador_comp;
}

\end{lstlisting}

\caption{Função Selection Sort com Contador\label{main}}
\end{figure}

\vspace*{7cm}

\begin{itemize}
\item {\large Insertion Sort}

O {\bf insertion sort}, ou ordenação por inserção, é um simples algoritmo de ordenação bastante eficiente quando aplicado a um pequeno número de elementos. Ele percorre um vetor de elementos da esquerda para direita e à medida que avança vai deixando os elementos mais à esquerda ordenados, podendo assim ser comparado como o modo que muitas pessoas ordenam cartas como em um jogo de baralho.
 \begin{itemize}
 \item {\bf Complexidade Pior Caso:} $O(n^2)$
 \item {\bf Complexidade Caso Médio:} $O(n^2)$
 \item {\bf Complexidade Melhor Caso:} $O(n)$
 \end{itemize}

\end{itemize}

\begin{figure}[htb]
\begin{lstlisting}[language=c]
int insertion_sort(int n, int v[MAX]){

    int i, j, x, z;
    int contador_comp = 0;
    for(i=1;i<n;i++){
        x = v[i];
        for(z=i-1;z>=0;z--, contador_comp++){}
        for(j=i-1;j>=0 && v[j] > x; j--){
            v[j+1] = v[j];
        }
        v[j+1] = x;
    }
return contador_comp;
}

\end{lstlisting}

\caption{Função Insertion Sort com Contador\label{main}}
\end{figure}

\vspace*{9cm}

\begin{itemize}
\item {\large Merge Sort}

O {\bf merge sort}, ou ordenação por inserção, é um simples algoritmo de ordenação bastante eficiente quando aplicado a um pequeno número de elementos. Ele percorre um vetor de elementos da esquerda para direita e à medida que avança vai deixando os elementos mais à esquerda ordenados, podendo assim ser comparado como o modo que muitas pessoas ordenam cartas como em um jogo de baralho.
 \begin{itemize}
 \item {\bf Complexidade Pior Caso:} $O(n$ log $n)$
 \item {\bf Complexidade Caso Médio:} $O(n$ log $n)$
 \item {\bf Complexidade Melhor Caso:} $O(n$ log $n)$
 \end{itemize}

\end{itemize}

\begin{figure}[htb]
\begin{lstlisting}[language=c]
void intercala(int p, int q, int r, int v[MAX]){
    int i, j, k, w[MAX];
    i = p;
    j = q;
    k = 0;
    while (i<q && j<r){
        contador_comp++;
        if(v[i] < v[j]){
            w[k] = v[i];
            i++;
        }
        else{
            w[k] = v[j];
            j++;
        }
        k++;
    }
    while(i < q){
        w[k] = v[i];
        i++;
        k++;
    }
    while(j < r){
        w[k] = v[j];
        j++;
        k++;
    }
    for(i=p; i<r; i++){
        v[i] = w[i-p];	
    }
}

\end{lstlisting}

\caption{Função Intercala (Merge Sort) com Contador\label{main}}
\end{figure}

\vspace*{2.5cm}

\begin{figure}[htb]
\begin{lstlisting}[language=c]
void mergesort(int p, int r, int v[MAX]){
    int q;
    if(p < r - 1){
        q = (p + r) /2;
        mergesort(p, q, v);
        mergesort(q, r, v);
        intercala(p, q, r, v);
    }
}


\end{lstlisting}

\caption{Função Merge Sort\label{main}}
\end{figure}

\begin{itemize}
\item {\large Quick Sort}

O {\bf quick sort} é um método de ordenação muito rápido e eficiente. É frequentemente usado na prática para ordenação já que é rápido "na média" e apenas para algumas entradas especiais o método é lento como os métodos elementares de ordenação.
 \begin{itemize}
 \item {\bf Complexidade Pior Caso:} $O(n^2)$
 \item {\bf Complexidade Caso Médio:} $O(n$ log $n)$
 \item {\bf Complexidade Melhor Caso:} $O(n$ log $n)$
 \end{itemize}

\end{itemize}

\begin{figure}[htb]
\begin{lstlisting}[language=c]
int separa(int p, int r, int v[MAX]){

    int x, i, j;
    x = v[p];
    i = p - 1;
    j = r + 1;
    while (1) {
        do {
            j--;	
        } while(v[j] > x);
        do {
            i++;
        } while(v[i] < x);
        if(i<j){
            contador_comp++;
            troca(&v[i], &v[j]);
        }	
        else{
            contador_comp++;
            return j;
        }
    }
}


\end{lstlisting}

\caption{Função Separa (Quick Sort) com Contador\label{main}}
\end{figure}

\begin{figure}[htb]
\begin{lstlisting}[language=c]
void troca(int *x, int *y){
    int temp;
    temp = *y;
    *y = *x;
    *x = temp;
}

\end{lstlisting}

\caption{Função Troca (Quick Sort)\label{main}}
\end{figure}

\vspace*{1.15cm}

\begin{figure}[htb]
\begin{lstlisting}[language=c]
void quicksort(int p, int r, int v[MAX]){

    int q;
    if(p < r){
        q = separa(p,r,v);
        quicksort(p, q, v);
        quicksort(q+1, r, v);
    }
}

\end{lstlisting}

\caption{Função Troca (Quick Sort)\label{main}}
\end{figure}

% \vspace*{8.5cm}

\section{Experimentação}

Para gerar os gráficos fizemos uma bateria de testes usando vetores cujo tamanho varia de 0 até 3000 elementos. E usamos 7 testes diferentes cada um com um vetor nos cinco algoritmos de ordenação. Os dados espeficicos de cada teste podem ser vistos no arquivo "Gráficos.txt" que está no mesmo diretório deste relatório.

O método que utilizamos para verificar o tempo de execução dos algoritmos é similar ao modo de uso do arquivo gerador.c. Nós criamos 7 arquivos de entrada, e executamos os algoritmos com o seguinte comando no terminal ( time ./algoritmo < teste ) que nos provia com o tempo de execução total do algoritmo. Depois de ter todos os dados necessários para gerar o gráfico utilizamos os próprios comandos do LaTeX para gerar os gráficos. Escolhemos separar os cinco algoritmos em 2 gráficos diferentes: um para o bubble, insertion e selection sort e outro para o quick e merge sort. Devido a similaridade do numero de comparações nos 3 primeiros algoritmos citados.

\vspace*{1.5cm}

\begin{itemize}
\item {\large Gráfico 1}

\vspace*{0.5cm}

\begin{figure}[!htb]
     \centering
     \includegraphics[scale=1]{grafico1.png}
\end{figure}

\item {\large Gráfico 2}

\vspace*{0.5cm}

\begin{figure}[!htb]
     \centering
     \includegraphics[scale=1]{grafico2.png}
\end{figure}


\end{itemize}

\end{document}



